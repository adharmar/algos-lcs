# algos-lcs
 This project tries to compute the normalized edit distance and the longest common subsequence between two sequences

Compilation:
The input files are to be given as arguments to the main function through the console. The entire file path needs to be specified if file is not in parent/working directory. Files are easily identified if the entire path is specified. The output is a file named lcsoutput.txt generated by the program. The file is rewritten on each execution of the program. The output file can be found in the parent/working directory of execution. 

What works?
All inputs are specified in two input files. The files are scanned into input strings. The strings can contain white spaces. Special characters such as $, new line, tab space and numbers (digits) also work with the implemented algorithm. But there is a catch. The tab spaces are currently represented as tab in the output file and similarly newline feeds are represented as a newline feed. The tab and newline feed characters are matched exactly and represented as such in the output file. Matching these to a dictionary of symbols or keys for these special characters and printing these symbols can be made possible, but it’s beyond the scope of this project. Characters are case-sensitive too.

What does not work?
Multiple files (>2 files) is not supported by the code presently. The entire file path needs to be specified for identification of the file correctly. Currently, the output file is generated in the parent/working directory. If required, this can be modified in the file opening segment in the main function of the code.

Environment:
Netbeans 8.0.2 IDE along with Java JDK 1.7 was used to develop the code.

Input and Output:
•	Input strings are taken from fully accessible files in local drive. The file locations are specified as the path for the strings to be populated. This path can be changed to test the code.
•	A commented section of the code also allows console input from users if necessary.
•	Output is written to a file names lcsoutput.txt.
•	A sample input and output file is also attached with this project folder.

Code Description:
•	The main function will take two input strings. These input strings can be obtained from two files by specifying their paths in the main method.
•	computeED function returns the edit distance of the given two strings. computeED function in turn uses computefn to calculate the edit distance arrays iteratively. One of the arrays is initialized in computeED function. The other array is computed by the computefn function. Then the computed second array is copied into the first array and the process is repeated until all characters of the first string are compared with the second string. The final array’s last element contains the edit distance. This is used by calNED to calculate the normalized edit distance.
•	formtable function forms the edit distance table. It initializes the two dimensional array which is filled by the formtablefn function iteratively. constructlcs function uses the formed edit distance table to iteratively construct the longest common subsequence with the help of the two input strings.
•	fmrow function computes the forward middle row. fmrow initializes two single dimensional arrays. One of the arrays is initialized in fmrow function. The other array is computed by the iterate function. Then the computed second array is copied into the first array and the process is repeated until all characters of the first string are compared with the second string. rmrow function computes the reverse middle row. reiterate function performs a similar function except that the neighbors used for computation are different as stated in the project description.
Algorithm & Data Structure Design:
•	Two single dimensional arrays of lengths equal to that of the second string are used in the computing the edit distance. Initially, one of these arrays is initialized with values obtained when comparing a null string with the second string. The second array’s first value is set to one more than the value of the first element in the first array. Then, the values in the second array are computed based on the three neighbors (top, left, diagonal top left) and the character of the first string and the character under consideration of the second string. After the array is computed, this is copied into the first array and the same process is repeated until all characters of the first string are compared with the second string characters. The final array’s last element holds the edit distance of the two strings.
•	For the lcs using the entire table, a two dimensional array of size  first string’s length against second string’s length (i.e. m x n ) is used. The table computing procedure is similar to the process in computing the arrays as described previously. Here the as we are storing the entire table, the array is not copied back. The entire m x n table with the two strings is used in back tracking the longest common subsequence using the constructlcs function.
•	For lcs using recursive method, the forward middle row is calculated using two single dimensional arrays of length equal to that of the second string’s length. The computation is similar to that of the array computation described previously but the computation stops at a point where the iteration count is equal to half that of the first string’s length. The reverse middle row is computed in a similar way with two single dimensional arrays of second string’s length and stops after computing for the other half. Now these two rows are used in forming the lcs recursively. The vertical point of split is found and the lcs function is called recursively.
•	When comparing two characters or a character and a string in the above two methods of constructing lcs, a stack is maintained to push the matched characters. Later this stack is popped entirely to construct the longest common subsequence. This can also be done using strings. In strings, the matched character is appended to a string appropriately and later returned if necessary.
